# AI 辅助编程

## 团队落地 AI 辅助编程和 Specs 实战

[万字长文讲解：团队落地 AI 辅助编程和 Specs 实战](https://mp.weixin.qq.com/s/YOlulBbwkR9N4er0lJrhfQ)

### 常见的 AI 辅助编程问题

大语言模型：

- • **目标漂移**：在多步骤、长流程的编程任务中（如复杂功能开发、项目重构），AI 执行到中后阶段易偏离初始目标，例如原本需求是优化数据库查询性能，后续却无端重写 UI 组件，本质是缺乏有效的目标锚定机制。
- • **重复犯错**：对已出现过的错误缺乏长期记忆，相同问题会反复出现（如未正确处理异步函数的 `await` 关键字、文件路径引用错误），无法自动沉淀历史解决方案。
- • **上下文爆炸**：为让 AI 掌握完整项目信息，需将大量代码、需求文档、历史对话塞进上下文窗口，导致模型处理效率下降、响应延迟，且易忽略关键信息。
- • **进度丢失**：依赖对话窗口存储任务状态，一旦对话重置、刷新或中断，之前的开发进度、中间决策、已积累的项目认知会全部消失，无法无缝续工。
- • **幻觉生成**：在缺乏明确参考依据时，可能编造不存在的 API 方法、语法规则或项目配置，生成看似合理但实际无法运行的代码，增加调试成本。

AI IDE：
- • **上下文管理能力不足**：多数 AI IDE 未建立独立的外部记忆机制，仍依赖模型自带的上下文窗口，无法高效关联项目文件、历史操作记录，难以支撑复杂任务的连贯开发。
- • **任务追踪与可视化缺失**：缺乏对编程任务的结构化拆解与进度可视化功能，无法像 `task_plan.md` 那样清晰呈现阶段划分、完成状态、决策依据，开发者难以掌控 AI 的工作轨迹。
- • **错误记录与复用薄弱**：未集成错误追踪体系，AI 遇到的报错、修复方案无法自动归档，既不便于开发者回溯问题根源，也无法让 AI 后续快速复用已验证的解决方案。
- • **文件协同与持久化不足**：对 AI 生成的中间产物（如调研笔记、技术选型文档）缺乏统一的存储与管理机制，文件分散且易丢失，无法形成可追溯、可复用的项目知识库。
- • **人机协作衔接不畅**：开发者难以直接干预 AI 的任务执行流程，例如无法通过编辑结构化计划文件调整开发方向，也缺乏便捷的方式审查 AI 的决策逻辑，导致人机协同效率低下。
- • **性能与成本失衡**：处理大规模项目时，频繁加载全量上下文会导致 IDE 运行卡顿，且重复处理相同静态内容（如项目框架定义、工具配置）会增加 Token 消耗，提升使用成本。

所以，在目前的技术局限下，要玩 AI 编程，其实还不能为所欲为，同时使用 AI 编程时也会碰到很多阻碍问题，降低了编程的体验和项目代码质量。

### AI 编程下的团队协作问题

**代码碎片化**
> 很多同事发现用 AI 写代码，可以早点下班，于是大家都用 AI 写代码，你写你的我写我的，导致成员各自使用 AI 生成代码，风格、逻辑差异显著，模块衔接困难，后期维护成本激增。反正同事用 AI 写的代码，我是压根不行维护。

**规范失控**
> 大家应该都有感受，在不同提示词、编写不同功能时，AI 编写的代码风格各异，没有统一的规范和风格，AI 生成代码可能偏离团队代码规范、安全标准，埋下质量隐患。

**知识孤岛**
> 个人使用 AI 积累的经验无法共享，团队整体效率难以提升。你用 cursor，我用 kiro，各写各的代码，没法为团队沉淀知识经验，提示词、功能历史记录、背景上下文等完全没法在团队内共享，每个人都得在本地使用 AI 阅读代码生成上下文记忆。

**协作低效**
> AI 写的代码实际上会出现一个简单的功能写一堆代码的情况，也有可能 A 同事写 A 功能时生成了 C，B 同事写 B 功能时又生成了一个类似的 C，项目各种代码错综复杂。导致难以统一任务分配、进行代码评审流程，导致信息传递滞后，冲突频发。

除了以上问题在团队编程中需要解决，很多公司都有代码质量规范要求、安全要求、单元测试覆盖率要求，所以基于这些问题和常见公司编程要求，团队 AI 编程的核心诉求应聚焦：
- • 维持一致代码质量
- • 防止安全漏洞
- • 减少重复工作量
- • 标准化协作流程
- • 加快开发周期
- • 实现从 “快速原型” 到 “工程化落地” 的跨越。

如何解决 AI 编程下的团队协作问题，并且真正落地单元测试、代码审查等技术要求 - AI Spec

### 规范开发(Spec development)

为了解决 AI 编写代码的问题，出现了 SDD(Spec-Driven Development) 这种概念，强调在使用 AI 编写代码之前，先有 Specification，以便约束 AI 生成高质量的、符合业务需求和技术要求的代码。
目前社区中主要存在三类 SDD 工具：OpenSpec、Kiro、Spec-Kit。

为了实现 Spec development，选择 SDD 工具时，需要考虑：
- • **工具与流程适配**：选择 Kiro 这类支持规范定制、多场景协作的 AI 工具，避免工具功能与团队流程脱节；
- • **重视规范落地**：将团队规则转化为可执行的钩子、Spec 模板，借助 AI 强制落地，而非仅停留在文档层面；
- • **构建协作文化**：鼓励成员主动共享 AI 使用经验、参与流程优化，避免 “单兵作战” 思维；
- • **平衡自动化与人工**：AI 负责标准化、重复性工作（如测试、规范检查），人类聚焦核心架构与创意决策，实现人机协同增效。

## AI Coding 长文分享：如何真正把工具用起来，从原理到实践

[AI Coding 长文分享：如何真正把工具用起来，从原理到实践](https://mp.weixin.qq.com/s/MjBVTfo6Kp2RDG6v46_BPA)

Token计算机制:
初始 Token 组成：初始输入 = SystemPrompt +用户问题 + Rules + 对话历史
用户问题 : 我们输入的文字 + 主动添加的上下文（图片、项目目录、文件）Rules：project rule + user rule + memories

### 提升对话质量：合理利用上下文窗口

Action 1：进行清晰的问题描述
描述问题时，我们最好能给出具体的功能、文件名、方法名、代码块，让模型能够通过语义检索等方式，用较短的路径找到代码，避免在检索这部分混杂太多弱相关内容，干扰上下文。

Action 2：把控上下文长度
在处理复杂问题时，采用上下文窗口大的模型/模式，尽量避免压缩。

Action 3：尽可能地使用Revert和新开对话
省上下文是一方面，维持上下文的简洁对模型回答质量提升也是有帮助的。因此，如果你的新问题跟历史对话关系不大，就最好新开一个对话。

在多轮对话中，如果有一个步骤出错，最好的方式也是会退到之前出错的版本，，基于现状重新调整 prompt 和更新上下文；而不是通过对话继续修改。否则可能导致上下文中存在过多无效内容。

Action 4：给出多元化的信息
我们不只可以粘代码、图片进去，还可以让模型参考网页、Git历史、当前打开的文件等信息，这样模型可以更好地理解问题。

采用渐进式开发，而不是大需求一口气梭哈

- 因为上下文窗口有限，任务粒度越小，AI 完成度越高分步骤代码量
- 便于做 Code Review

## 如何用AI Coding和Claude Code提升开发效率？看我的全流程复盘

[如何用AI Coding和Claude Code提升开发效率？看我的全流程复盘](https://mp.weixin.qq.com/s/6j-MqSrJz5YlKAe2LZW6pg)

1. 使用结构化的方式表示 Prompt: COSTAR框架，是2023年新加坡prompt大赛冠军总结出来的一个提示词编写框架，他将Prompt分成了Context、Objective、Style、Tone、Audience、Response这几个部分，分别表示任务的背景、agent的目标、风格、回复预期、受众以及响应格式要求。
2. 小步快跑，每一步需要可验证: 不要等代码全生成了，然后一次性调试，好的代码应该像细菌🦠一样（by Karpathy），精炼，模块化，闭包( copy paste-able)。
3. AI生成的方案和代码必须要Review: 不要期望一次命令就能完成一个完整需求，AI认为的完成，有可能并不是实际的完成。一方面可能会因为上下文长度的原因，遗忘，或者产生幻觉。 另外一方面对于项目的了解程度的片面性，生产出来的代码质量或技术方案不够好。
4. 频繁提交到git仓库: git history就是项目的另外一份README.md，抑或者是上下文
5. 有效管理上下文
   1. 提供精确信息当已确定修改范围时，应提供准确的文件路径和相关细节。先通过与 AI 逐步沟通，获取并明确关键信息，形成清晰上下文后，再让AI执行。
   2. 信息压缩策略: 手动筛选重要信息，只保留有价值的部分
   3. 控制任务粒度
   4. 利用外部记忆: 存储在外部文档中, 比如 Claude.md。先让AI针对代码写说明文档(README.md)，然后再让他参与到写代码 。

### Claude Code使用经验分享

Claude Code本质上是由一个主模型搭配15个专用工具组成的智能体系统。其工具集主要包括：
- 任务列表管理
- 文件编辑功能
- Bash命令执行
- 内容查找（Grep、Glob）
- Web搜索能力

1. 构建项目的rules和workflow：通过/init指令，可以让Claude Code扫描整个工程，了解项目结构，并将结果写入CLAUDE.md文件
2. 上下文管理策略：
   1. 定期使用/compact命令：上下文容易超出限制，需要主动压缩，否则模型可能遗忘早期重要信息；
   2. 及时更新README.md和CLAUDE.md，将其作为上下文存储的补充；
   3. 任务结束后，使用/clean清除上下文，保持环境整洁；
3. 先plan再code(shift + tab)当项目复杂度高、代码设计量大时，采用"计划先行"模式能显著提升效率：先让AI分析修改点，制定详细计划，然后再执行具体编码工作。
4. 使用git worktree多个Claude Code协同工作，但不建议过多，以免人工切换上下文带来认知负担
5. 有效利用MCP
   1. Context7 MCP：能够从源代码直接提取最新、特定版本的文档和代码示例，并将其直接放入prompt中
   2. apifox MCP：接口文档，测试用例等

## AI编码实践案例

[AI编码实践：从Vibe Coding到SDD](https://mp.weixin.qq.com/s/xVff9O2DPLssbfzp_GRwXQ)

Rules约束 - 建立AI的"项目规范"

尝试用Rules文件来约束AI的行为，将项目规范、架构模式、领域知识固化下来。
Rules文件体系：

```sh
.aone_copilot/
├── rules/
│   ├── code-style.aonerule           # 代码风格规范
│   ├── project-structure.aonerule    # 项目结构规范
│   └── features.aonerule              # 功能实现规范
└── tech/
    ├── xx秒杀-技术方案.md      # 具体需求的技术方案
    └── xx红包模块-技术方案.md
```

Speckit文件体系：

```sh
├── .specify/
│   ├── memory/
│   │   └── constitution.md  # 整个项目的原则
│   ├── scripts/
│   └── templates/
├── specs/
│   └── 001-nn-redpacket-module/
│       ├── checklists/
│       │   └── requirements.md
│       ├── contracts/
│       │   └── api-contract.md
│       ├── data-model.md
│       ├── plan.md                # 实施计划
│       ├── quickstart.md
│       ├── research.md
│       └── spec.md                # 规格说明
└── req/
    └── nn-redpacket.md
```

Rules文件内容示例：

项目全局的宪章，constitution.md 以下是部分节选：

```md
## 核心原则

### I. 模块化服务架构
所有服务必须遵循模块化设计原则，具有明确的关注点分离和定义良好的接口。每个模块应具有单一职责并可独立部署。模块必须以松耦合和高内聚的方式设计，以增强可维护性和可扩展性，遵循最小依赖原则。
### II. 阿里巴巴开发标准
所有代码必须遵循阿里巴巴Java开发指南（基于阿里巴巴Java编码规范）。这包括命名约定、异常处理实践、日志标准、安全最佳实践和性能优化模式。代码必须遵守样式一致性要求，以保持代码库的统一性。
### III. 质量保证实践
全面测试是强制性的：对所有业务逻辑进行单元测试，对服务交互进行集成测试，对API兼容性进行合同测试。代码覆盖率必须保持在80％以上，特别关注关键业务路径。代码质量工具必须集成到CI/CD管道中以执行标准，遵循阿里巴巴开发规范以确保质量和可靠性。
### IV. 模块设计原则
遵循单一职责原则，每个模块都有一个明确的目的。模块必须以松耦合和高内聚的方式设计，遵循关注点分离原则。模块边界应与业务能力和领域上下文对齐。所有模块都遵循最小依赖原则，仅导入必要的依赖项以减少系统复杂性。
### V. 项目架构设计原则
本项目采用分层架构设计，通过模块化组织代码，支持淘特投放业务的各种场景需求。架构层次包括：
1. **接入层**：处理请求接入和协议转换
2. **解决方案层**：业务解决方案的统一入口
3. **子解决方案层**：细粒度的业务处理能力
4. **模块构建层**：按业务功能划分的模块构建器
5. **数据服务层**：负责各种业务数据的获取、处理和封装
6. **外部服务层**：负责调用外部服务并进行模型转换
7. **领域模型层**：定义核心业务对象和数据传输对象
8. **基础设施层**：包含基础组件和框架封装
9. **通用模块层**：公共组件和工具类
### VI. 依赖管理
遵循最小依赖原则：每个模块应只拥有其实际需要的依赖项。避免模块之间的循环依赖。使用依赖注入实现松耦合。定期审核和更新依赖项以最小化安全漏洞。这确保了可维护和高效的代码结构。
### VII. 代码风格一致性
在整个项目中保持一致的代码风格，使用标准化的格式化规则。所有代码在合并前必须通过静态分析检查。一致地遵循设计模式，并对与标准实践的任何偏差提供清晰的证明。这确保了统一的代码规范和样式，符合项目标准。
### VIII. Speckit中文本地化
所有speckit相关文件、文档和配置都应使用中文，以支持本地开发团队。`.specify/`和`specs/`目录中的文件和相关speckit构件必须使用中文，以便本地开发人员更好地理解和维护，同时应为可能服务国际市场面向用户的组件保留国际化支持。
## 安全和合规要求
所有代码必须符合阿里巴巴的安全标准，并在部署前进行强制性安全审查。必须为所有暴露的端点实现适当的身份验证和授权。敏感数据必须根据内部合规要求进行处理。必须扫描依赖项中的安全漏洞。
## 开发工作流程
1. 所有代码更改必须遵循标准的阿里巴巴开发工作流程：功能分支、代码审查、自动化测试和CI/CD管道验证。拉取请求必须通过所有测试并获得指定审阅者的批准后才能合并。除非明确批准进行具有迁移计划的破坏性更改，否则所有更改必须向后兼容。每次更改都必须遵循模块设计原则并保持代码风格一致性。
2. 所有操作不要创建新分支，而是在当前分支下进行
3. 代码生成必须遵循code-generation-prompt.aonerule文件
## 治理
本宪法凌驾于所有其他开发实践之上，必须在存储库中的所有工作中遵循。对本宪法的任何修改都需要正式文档、团队批准和迁移计划。所有PR和代码审查必须验证是否符合这些原则。
```

代码风格规范（code-style.aonerule）
```md
# 代码风格规范

## Java代码规范
- 类名使用大驼峰命名法（PascalCase）
- 方法名和变量名使用小驼峰命名法（camelCase）
- 常量使用全大写，单词间用下划线分隔（CONSTANT_CASE）

## 空值判断
- 集合判空统一使用：CollectionUtils.isEmpty() 或 isNotEmpty()
- 字符串判空统一使用：StringUtils.isBlank() 或 isNotBlank()
- 对象判空统一使用：Objects.isNull() 或 Objects.nonNull()

## 日志规范
- 使用 LogUtil 工具类记录日志
- 错误日志格式：LogUtil.error("类名, 方法名, 错误描述, 关键参数={}", param, exception)

## 注解使用
- Service类使用 @Component 注解
- 数据服务实现 DataService<T> 接口
- 模块构建器继承 BaseModuleBuilder<T>
```
