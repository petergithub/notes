# Regular_expression Notes

[Regular_expression](https://en.wikipedia.org/wiki/Regular_expression#POSIX_basic_and_extended)

## 正则表达式入门

[regex](http://deerchao.net/tutorials/regex/regex.htm#mission)

### 元字符

表1.常用的元字符

 | 代码 | 说明                         |
 | ---- | ---------------------------- |
 | `.`  | 匹配除换行符以外的任意字符   |
 | `\w` | 匹配字母或数字或下划线或汉字 |
 | `\s` | 匹配任意的空白符             |
 | `\d` | 匹配数字                     |
 | `\b` | 匹配单词的开始或结束         |
 | `^`  | 匹配字符串的开始             |
 | `$`  | 匹配字符串的结束             |

`(`, `)`

1. `\b`是正则表达式规定的一个特殊代码（某些人叫它元字符，metacharacter），代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是`\b`并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置.
如果需要更精确的说法，`\b`匹配这样的位置：它的前一个字符和后一个字符不全是(一个是,一个不是或不存在)`\w`
很多单词里包含hi这两个连续的字符，比如him,history,high等等。用hi来查找的话，这里边的hi也会被找出来。如果要精确地查找hi这个单词的话，我们应该使用`\bhi\b`
假如你要找的是hi后面不远处跟着一个Lucy，你应该用`\bhi\b.*\bLucy\b`

2. `0\d{2}-\d{8}`。这里`\d`后面的`{2}`(`{8}`)的意思是前面`\d`必须连续重复匹配2次(8次)
3. `^(?!#).*` find all lines which are not start with #

### 字符转义

使用`\`来取消这些字符的特殊意义。因此，你应该使用`\.`和`\*`。当然，要查找`\`本身，你也得用`\\`

### 重复

表2.常用的限定符

| 代码/语法 | 说明             |
| --------- | ---------------- |
| `*`       | 重复零次或更多次 |
| `+`       | 重复一次或更多次 |
| `?`       | 重复零次或一次   |
| `{n}`     | 重复n次          |
| `{n,}`    | 重复n次或更多次  |
| `{n,m}`   | 重复n到m次       |

下面是一些使用重复的例子：
`Windows\d+`匹配Windows后面跟1个或更多数字
`^\w+`匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)
`.*` 之后的 `?` 符号和其他一些匹配规则意味着“尽可能少的匹配” 非贪婪的匹配

### 字符类

`[aeiou]`匹配任何一个英文元音字母，`[.?!]`匹配标点符号(.或?或!)
`[0-9]`代表的含意与`\d`是一致的：一位数字；
`[a-z0-9A-Z_]`也完全等同于`\w`（如果只考虑英文的话）
`\(?0\d{2}[) -]?\d{8}` 这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符`\(`,它能出现0次或1次(`?`),然后是一个0，后面跟着2个数字(`\d{2}`)，然后是`)`或`-`或空格中的一个，它出现1次或不出现(`?`)，最后是8个数字(`\d{8}`),  但这个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式

### 分枝条件

分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开
`0\d{2}-\d{8}|0\d{3}-\d{7}`这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)
`\(?0\d{2}\)?[- ]?\d{8}|0\d{2}[- ]?\d{8}`这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。
`\d{5}-\d{4}|\d{5}`这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：**使用分枝条件时，要注意各个条件的顺序**。如果你把它改成`\d{5}|\d{5}-\d{4}`的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。**原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了**

### 分组

重复多个字符, 用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了
`(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：`\d{1,3}`匹配1到3位的数字，`(\d{1,3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字`(\d{1,3})`。
理解这个表达式的关键是理解`2[0-4]\d|25[0-5]|[01]?\d\d?`，这里我就不细说了，你自己应该能分析得出来它的意义。

### 反义

有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义
表3.常用的反义代码
| 代码/语法  | 说明                                       |
| ---------- | ------------------------------------------ |
| `\W`       | 匹配任意不是字母，数字，下划线，汉字的字符 |
| `\S`       | 匹配任意不是空白符的字符                   |
| `\D`       | 匹配任意非数字的字符                       |
| `\B`       | 匹配不是单词开头或结束的位置               |
| `[^x]`     | 匹配除了x以外的任意字符                    |
| `[^aeiou]` | 匹配除了aeiou这几个字母以外的任意字符      |

例子：
`\S+`匹配不包含空白符的字符串。
`<a[^>]+>`匹配用尖括号括起来的以a开头的字符串。

### 后向引用

1

### 贪婪模式（Greedy）和非贪婪模式（Lazy）

#### 贪婪模式

定义：正则表达式去匹配时，会尽量多的匹配符合条件的内容，

标识符：`+，?，*，{n}，{n,}，{n,m}`

例子：字符串 'aacbacbc'，reg `/a.*b/` 匹配结果是 `aacbacb`

#### 非贪婪匹配模

定义：正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有g，开启下一组匹配)

标识符：`+?，??，*?，{n}?，{n,}?，{n,m}?`，就是贪婪模式的标识符后面加上一个`?`

例子：字符串 'aacbacbc'，reg `/a.*?b/` 匹配结果是 `aacb`

## Example

`^[^#].*[^\s\s]$` 匹配中结尾不是两个空格的行, 修改mark down 文件
`[^0-9]*,` matches string start with non-number until to (,)

### 替换命中词前后的内容，且保留命中词

在 find 语句中把需要保留的词用 `()` 括起来

#### 需求：数字序号是中文括号包含的比如（1），需要替换成 1.

Find:`（(\d+)）` Replace: `$1.`

#### 需求 将所有的方法调用都套上print()

Find: `(num.\w+())` Replace: `print($1)`

#### 需求 将SQL语句中的多余字符替换掉

原文：`SELECT platform, sales_medium.platform_anchor_id AS sales_medium_platform_anchor_id FROM sales_medium`
需求：把 `sales_medium.platform_anchor_id AS sales_medium_platform_anchor_id` 替换成 `platform_anchor_id`
Find: `sales_medium\.(.*?) AS.*?,` Replace: `$1,`

## filename

[Unix Reg exp](http://www.interlude.org.uk/unix/Unix%20Reg%20exp%20stuff.htm )

Matching file names with regular expressions
You can use the following metacharacters within any shell to create regular expressions that match file names.

* `?`       matches any single character
* `*`       matches any number of any characters
* `[nnn]`   matches any of the enclosed characters
* `[!nnn]`  matches any character that is not enclosed
* `[n-n]`   matches any character in this range

example: `ls *.fm`, `rm prog.?`, `cp [pP]art[0-9] ../book`
