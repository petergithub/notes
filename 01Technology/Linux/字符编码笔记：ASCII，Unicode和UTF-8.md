# 字符编码笔记：ASCII，Unicode 和 UTF-8

* Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储，这就涉及到编码方法。
* UTF-8 使用1~4个字节表示一个符号，是 Unicode 的实现方式之一。
* UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）
* UTF-32 是最直观的编码方法，每个码点使用四个字节表示，字节内容一一对应码点

## ASCII 码

一个字节（byte）八个二进制位可以组合出256种状态。每一个状态对应一个符号，就是256个符号，从 `0000 0000` 到 `1111 1111`。

上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。

ASCII 码一共规定了128个字符的编码，对英语字符与二进制位之间的关系，做了统一规定。比如空格`SPACE`是32（二进制`0010 0000`），大写的字母`A`是65（二进制`0100 0001`）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为`0`。

## Unicode

Unicode 源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。

Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，`U+0639`表示阿拉伯字母`Ain`，`U+0041`表示英语的大写字母`A`，`U+4E25`表示汉字`严`。具体的符号对应表，可以查询[unicode.org](https://www.unicode.org)，或者专门的[汉字对应表](http://www.chi2ko.com/tool/CJK.htm)。

[Q: How many characters are in Unicode?](https://www.unicode.org/faq/basic_q.html#2a)：The short answer is that as of Version 13.0, the Unicode Standard contains 143,859 characters

## Unicode 的问题

需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

比如，汉字`严`的 Unicode 是十六进制数`4E25`，转换成二进制数足足有15位（`100 1110 0010 0101`），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。

这里就有两个严重的问题，第一个问题是，如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。

它们造成的结果是：1）出现了 Unicode 的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示 Unicode。2）Unicode 在很长一段时间内无法推广，直到互联网的出现。

## UTF-8

互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。其他实现方式还包括 UTF-16（字符用两个字节或四个字节表示）和 UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，**UTF-8 是 Unicode 的实现方式之一**。

UTF-8 最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。

UTF-8 的编码规则很简单，只有二条：

1）对于单字节的符号，字节的第一位设为`0`，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。

2）对于`n`字节的符号（`n 1`），第一个字节的前`n`位都设为`1`，第`n + 1`位设为`0`，后面字节的前两位一律设为`10`。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

下表总结了编码规则，字母`x`表示可用编码的位。

> Unicode符号范围(十六进制)    | UTF-8编码方式（二进制）
> ----------------------    | ---------------------------------------------
> 0000 0000  -  0000 007F   | 0xxxxxxx
> 0000 0080  -  0000 07FF   | 110xxxxx 10xxxxxx
> 0000 0800  -  0000 FFFF   | 1110xxxx 10xxxxxx 10xxxxxx
> 0001 0000  -  0010 FFFF   | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是`0`，则这个字节单独就是一个字符；如果第一位是`1`，则连续有多少个`1`，就表示当前字符占用多少个字节。

下面，还是以汉字`严`为例，演示如何实现 UTF-8 编码。

`严`的 Unicode 是`4E25`（`100 1110 0010 0101`），根据上表，可以发现`4E25`处在第三行的范围内（`0000 0800 - 0000 FFFF`），因此`严`的 UTF-8 编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从`严`的最后一个二进制位开始，依次从后向前填入格式中的`x`，多出的位补`0`。这样就得到了，`严`的 UTF-8 编码是`11100100 10111000 10100101`，转换成十六进制就是`E4B8A5`。

使用 UTF-8 格式的每个 UTF-16 字符的字节数可根据表 1 UTF-8 的位分布 来确定。

表 1. UTF-8 的位分布
| 代码值 （二进制）          | UTF-16 （二进制）                    | 第一个字节 （二进制） | 第二个字节 （二进制） | 第三个字节 （二进制） | 第四个字节 （二进制） |
| ---                     | ---                                 | ---               | --- | --- | --- |
| 00000000 0xxxxxxx       | 00000000 0xxxxxxx                   | 0xxxxxxx                       |  |  |  |
| 00000yyy yyxxxxxx       | 00000yyy yyxxxxxx                   | 110yyyyy                       | 10xxxxxx |  |  |
| zzzzyyyy yyxxxxxx       | zzzzyyyy yyxxxxxx                   | 1110zzzz                       | 10yyyyyy | 10xxxxxx |  |
| uuuuu zzzzyyyy yyxxxxxx | 110110ww wwzzzzyy 110111yy yyxxxxxx | 11110uuu （其中 uuuuu = wwww+1） | 10uuzzzz | 10yyyyyy | 10xxxxxx |

在上表中列示的每个代码值中，u、w、x 、y 和 z 串都是字符的位表示。例如，U+0080 变换为二进制格式中的 11000010 10000000，而代用字符对 U+D800 U+DC00 变为 二进制格式中的 11110000 10010000 10000000 10000000。

## 大端 Big endian, 小端 Little endian

UCS-2 格式可以存储 Unicode 码（码点不超过`0xFFFF`）。以汉字`严`为例，Unicode 码是`4E25`，需要用两个字节存储，一个字节是`4E`，另一个字节是`25`。存储的时候，`4E`在前，`25`在后，这就是 Big endian 方式；`25`在前，`4E`在后，这是 Little endian 方式。

Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（zero width no-break space），用`FEFF`表示。这正好是两个字节，而且`FF`比`FE`大`1`。

如果一个文本文件的头两个字节是`FE FF`，就表示该文件采用大头方式；如果头两个字节是`FF FE`，就表示该文件采用小头方式。

Unicode编码中表示字节排列顺序的文件头，叫做`BOM（byte-order mark）`，`FFFE`和`FEFF`就是不同的BOM。

UTF-8文件的BOM是“EF BB BF”，但是UTF-8的字节顺序是不变的，因此这个文件头实际上不起作用。

### 大端小端简介

* 大端：最高有效字节在前面，摩托罗拉（Motorola）的PowerPC系列，IBM，TCP/IP 网络传输 使用
* 小端：最低有效字节在前面，Intel的 x86系列

ARM既可以工作在大端模式，也可以工作在小端模式，一般ARM都默认是小端模式

十六进制的 0x1A2B3C4D

* 大端表示为 1A 2B 3C 4D
* 小端表示为 4D 3C 2B 1A

### 大端小端详细介绍

位(bit)：计算机中的最小数据单位，计算机存储的都是二进制0和1这两个鬼。

字节(Byte)：字节是存储空间的基本计量单位，也是内存的基本单位，也是编址单位。

每个地址存一个字节，2位16进制数是一个字节（`0xFF = 11111111`）

对于多字节数据，如整数（32位机中一般占4字节），在不同的处理器的存放方式主要有两种，以内存中 `0x1A2B3C4D` 的存放方式为例，分别有以下几种方式：

#### 大端序

数据以8bit为单位: 内存地址增长方向 ---> 0x1A 0x2B 0x3C 0x4D

最高位字节是0x1A 存储在最低的内存地址处。下一个字节0x2B存在后面的地址处。正类似于十六进制字节从左到右的阅读顺序

数据以16bit为单位: 内存地址增长方向 ---> 0x1A2B 0x3C4D

最高的16bit单元0x1A2B存储在低位。

#### 小端序

数据以8bit为单位: 内存地址增长方向 ---> 0x4D 0x3C 0x2B 0x1A

最低位字节是0x4D 存储在最低的内存地址处。后面字节依次存在后面的地址处

数据以16bit为单位: 内存地址增长方向 ---> 0x3C4D 0x1A2B

最低的16bit单元0x3C4D存储在低位。

#### 比特序之 Little-Endian & Big-Endian

CPU存储一个字节的数据时，其字节内的8个比特之间的顺序也有Big-Endian和Little-Endian之分。

实际上，由于CPU存储数据操作的最小单位是一个字节，其内部的比特序是什么样的，对我们的程序来说是一个黑盒子。给一个指向0xB4这个数的指针，无论是大端还是小端，程序通过这个指针访问后得到的数就是0xB4

大端和小端描述的是字节之间的关系，而MSB、LSB描述的是Bit位之间的关系

MSB的意思是：全称为Most Significant Bit，在二进制数中属于最高有效位，MSB是最高加权位，与十进制数字中最左边的一位类似。

LSB的意思是：全称为Least Significant Bit，在二进制数中意为最低有效位，一般来说，MSB位于二进制树的最左侧，LSB位于二进制数的最右侧。

### 大端模式的优势

基于其存储特点，符号位在所表示的数据的内存的第一个字节中，便于快速判断数据的正负和大小（CPU做数值运算时从内存中依顺序依次从低位地址到高位地址取数据进行运算，大端就会最先拿到数据的(高字节的)符号位）。

### 小端模式的优势

基于其存储特点，内存的低地址处存放低字节，所以在强制转换数据时不需要调整字节的内容（比如，把int---4字节强制转换成short---2字节，就可以直接把int数据存储的前两个字节给short就行，因为其前两个字节刚好就是最低的两个字节，符合转换逻辑；另外CPU做数值运算时从内存中依顺序依次从低位地址到高位地址取数据进行运算，开始只管取值，最后刷新最高位地址的符号位就行，这样的运算方式会更高效一些）。

## UTF-16

UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。它的编码规则很简单：**基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）**。

最前面的 65536 个字符位，称为`基本平面`（缩写 `BMP, Basic Multilingual Plane`），它的码点范围是从 0 一直到 2^16-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。

剩下的字符都放在`辅助平面`（缩写 SMP, Supplementary），码点范围从 U+010000 一直到 U+10FFFF。

这里有一个很巧妙的地方，在基本平面内，从 `U+D800` 到 `U+DFFF` 是一个保留的空字段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。辅助平面的字符位共有 2^20 个，因此表示这些字符至少需要 20 个二进制位。UTF-16 将这 20 个二进制位分成两半，前 10 位映射在 `U+D800` 到 `U+DBFF`（空间大小 2^10），称为高位（H），后 10 位映射在 `U+DC00` 到 `U+DFFF`（空间大小 2^10），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。

因此，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。

Windows 内核、Java、Objective-C (Foundation)、JavaScript 中都会**将字符的基本单元定为两个字节的数据类型**，也就是我们在 C / C++ 中遇到的 wchar_t 类型或 Java 中的 char 类型等等，这些类型占内存两个字节，因为 Unicode 中常用的字符都处于 `0x0000 - 0xFFFF` 的范围之内，因此两个字节几乎可以覆盖大部分的常用字符。

## UTF-32

UTF-32 是最直观的编码方法，每个码点使用四个字节表示，字节内容一一对应码点。比如，码点 0 就用四个字节的 0 表示，码点 597D 就在前面加两个字节的 0。

```text
U+0000 = 0x0000 0000
U+597D = 0x0000 597D
```

UTF-32 的优点在于，转换规则简单直观，查找效率高。缺点在于浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。

## UCS-2 编码

互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的 Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集。

1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。

UCS 的开发进度快于 Unicode，1990 年就公布了第一套编码方法 UCS-2，使用 2 个字节表示已经有码点的字符。（那个时候只有一个平面，就是基本平面，所以 2 个字节就够用了。）UTF-16 编码迟至 1996 年 7 月才公布，明确宣布是 UCS-2 的超集，即基本平面字符沿用 UCS-2 编码，辅助平面字符定义了 4 个字节的表示方法。

两者的关系简单说，就是 UTF-16 取代了 UCS-2，或者说 UCS-2 整合进了 UTF-16。所以，现在只有 UTF-16，没有 UCS-2。

那么，为什么 JavaScript 不选择更高级的 UTF-16，而用了已经被淘汰的 UCS-2 呢？

答案很简单：非不想也，是不能也。因为在 JavaScript 语言出现的时候，还没有 UTF-16 编码。

## Reference

[字符编码笔记：ASCII，Unicode 和 UTF-8 - 阮一峰的网络日志](https://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

[彻底弄懂Unicode编码 - 李宇仓 | Li Yucang](https://liyucang-git.github.io/2019/06/17/彻底弄懂Unicode编码/)

[Unicode 字符编码 - IBM 文档](https://www.ibm.com/docs/zh/db2/11.1?topic=support-unicode-character-encoding)

## More Information

[The Unicode Standard, Version 4.0--online edition](http://www.unicode.org/versions/Unicode4.0.0/ch02.pdf)

[Supplementary Characters in the Java Platform](https://www.oracle.com/technical-resources/articles/javase/supplementary.html)

[Unicode (The Java™ Tutorials > Internationalization > Working with Text)](https://docs.oracle.com/javase/tutorial/i18n/text/unicode.html)
