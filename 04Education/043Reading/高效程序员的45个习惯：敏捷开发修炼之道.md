# 高效程序员的45个习惯：敏捷开发修炼之道

书名原文：Practices of an Agile Developer: Working in the Real World
（美） 亨特（Hunt,A.）著；钱安川，郑柯译.

## 推荐序一

一般误认为敏捷就是快，越快就是越敏捷——字典上的名词解释是其依据。岂不知它本来要以“lightweight processes”（轻量级过程）命名，只不过有些参会者不喜欢被看做是在拳台上跳来跳去的轻量级拳手，所以才用了“敏捷”这个词。

还有其他一些误解是，敏捷就是只写代码不写文档；敏捷需要重构而无需设计；敏捷迭代就是尽量做到最小，以至于一个小时就好几次；敏捷需要天才的程序员才能应用，其他人都会水土不服；如此这般。

## 第1章　敏捷——高效软件开发之道

### 敏捷开发宣言

我们正通过亲身实践和帮助他人实践，揭示了一些更好的软件开发方法。通过这项工作，我们认为：

* 个体和交互胜过过程和工具
* 可工作的软件胜过面面俱到的文档
* 客户协作胜过合同谈判
* 响应变化胜过遵循计划

虽然右项也有价值，但我们认为左项具有更大的价值。
敏捷宣言作者，2001年版权所有。
更多详细信息可以访问agilemanifesto.org。

### 敏捷的精神

敏捷方法可以快速地响应变化，它强调团队合作，人们专注于具体可行的目标（实现真正可以工作的软件），这就是敏捷的精神。它打破了那种基于计划的瀑布式软件开发方法，将软件开发的实际重点转移到一种更加自然和可持续的开发方式上。

它要求团队中的每一个人（包括与团队合作的人）都具备职业精神，并积极地期望项目能够获得成功。它并不要求所有人都是有经验的专业人员，但必须具有专业的工作态度——每个人都希望尽最大可能做好自己的工作。

如果在团队中经常有人旷工、偷懒甚至直接怠工，那么这样的方法并不适合你，你需要的是一些重量级的、缓慢的、低生产率的开发方法。如果情况并非如此，你就可以用敏捷的方式进行开发。

### 开发要持续不断，切勿时续时断 Continuous development, not episodic

这意味着你不会在项目结束的时候才开始测试，不会在月底才进行一次系统集成，也不会在一开始编码的时候就停止收集需求和反馈。

相反，这些活动会贯穿项目的整个生命周期。事实上，只要有人继续使用这个软件，开发就没有真正结束。我们进行的是持续开发、持续反馈。你不需要等到好几个月之后才发现问题：越早发现问题，就越容易修复问题，所以应该就在此时此刻把问题修复。

### 敏捷的修炼之道

**敏捷开发就是在一个高度协作的环境中，不断地使用反馈进行自我调整和完善。**

下面将扼要讲述它的具体含义，以及敏捷的团队应该采取什么样的工作和生活方式。

1. 首先，它要整个团队一起努力。一起共享代码和必要的开发任务。同时和客户或者软件的用户紧密工作在一起，并且尽可能早且频繁地给他们演示最新的系统。
2. 你要不断从自己写的代码中得到反馈，并且使用自动化工具不断地构建（持续集成）和测试系统。在前进过程中，在功能不变的情况下，重新设计部分代码，改善代码的质量。这就是所谓的重构，它是软件开发中不可或缺的一部分——编码永远没有真正意义上的“结束”。
3. 要以迭代的方式进行工作：确定一小块时间（一周左右）的计划，然后按时完成它们。给客户演示每个迭代的工作成果，及时得到他们的反馈（这样可以保证方向正确），并且根据实际情况尽可能频繁地发布系统版本让用户使用。

### 敏捷工具箱

Wiki，版本控制，单元测试，自动构建

## 第2章　态度决定一切

专业的态度应该着眼于项目和团队的积极结果，关注个人和团队的成长，围绕最后的成功开展工作。

软件项目时常伴有时间压力——压力会迫使你走捷径，只看眼前利益。但是，任何一个有经验的开发者都会告诉你，欲速则不达（我们在第15页将介绍如何避免这个问题）。

只有在你对项目、工作、事业有一个专业的态度时，使用敏捷方法才会生效。如果态度不正确，那么所有的这些习惯都不管用。

### 1　做事

重点是做事。你应该把重点放到解决问题上，而不是在指责犯错者上面纠缠。

### 2　欲速则不达

我们经常会遇到这种情况，出现了一个bug，并且时间紧迫。快速修复确实可以解决它——只要新加一行代码或者忽略那个列表上的最后一个条目，它就可以工作了。但接下来的做法才能说明，谁是优秀的程序员，谁是拙劣的代码工人。

拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。

优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。

#### 解决办法

不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“＋1或-1”的代码。阅读代码的频率越高越好。实行代码复审，不仅有助于代码更好理解，而且是发现bug最有效的方法之一（见第165页，习惯44）。 不要孤立地编码 Don’t code in isolation

另一种防止代码难懂的重要技术就是单元测试。

### 3　对事不对人

对一个明显的错误有哪些常见的反应。

* 否定个人能力。（不可能成功）

* 指出明显的缺点，并否定其观点。（至少观点明确，但也不能给太多的帮助）

* 询问你的队友，并提出你的顾虑。（没有谴责，没有评判，只是简单地表达自己的观点）

用Les Brown[4]的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”

#### 团体决策的骆驼

一些有效的特殊技术：

1. 设定最终期限
2. 逆向思维
3. 设立仲裁人
4. 支持已经做出的决定

设计充满了妥协（生活本身也是如此），成功属于意识到这一点的团队。工作中不感情用事是需要克制力的，而你若能展现出成熟大度来，大家一定不会视而不见。这需要有人带头，身体力行，去感染另一部分人。

### 4　排除万难，奋勇前进

当你勇敢地站出来时，如果受到了缺乏背景知识的抉择者的抵制，你需要用他们能够听懂的话语表达。**“更清晰的代码”是无法打动生意人的。节约资金、获得更好的投资回报，避免诉讼以及增加用户利益，会让论点更有说服力。**

## 第3章　学无止境

许多新技术都基于现有的技术和思想。它们会加入一些新的东西，这些新东西是逐步加入的量。如果你跟踪技术变化，那么学习这些新东西对你来说就是了解这些增量变化。如果你不跟踪变化，技术变化就会显得很突然并且难以应付。

学习新的技术和新的开发方法很重要，同时你也要能摒弃陈旧和过时的开发方法。

当我们谈到变化这个话题的时候，要认识到你对问题的理解在整个项目期间也是在变化的。

### 5　跟踪变化

### 6　对团队投资

### 7　懂得丢弃

### 8　打破砂锅问到底

### 9　把握开发节奏

在许多不成功的项目中，基本上都是随意安排工作计划，没有任何的规律。那样的随机安排很难处理。你根本不知道明天将会发生什么，也不知道什么时候开始下一轮的全体“消防演习”。

站立会议（习惯38，第148页）最好每天在固定的时间和地点举行，比如说上午10点左右。要养成这样的习惯，在那时就准备好一切参加站立会议。
最大的节拍就是迭代时间（习惯17，第69页），一般是1～4周的时间。

## 第4章　交付用户想要的软件

在本章中，我们会介绍如何达到敏捷的目标。首先，要介绍为什么用户和客户参与开发如此重要，以及为什么让客户做决定（从第45页开始）。设计是软件开发的基础，没有它很难做好开发，但你也不能被它牵制。从第48页开始，将介绍如何让设计指导而不是操纵开发。说到牵制，你应确保在项目中引入合适的技术。你需要合理地使用技术（第52页介绍）。

为了让软件符合用户的需求，要一直做下面的准备工作。为了降低集成新代码带来的破坏性变化，你要提早集成，频繁集成（第58页）。当然，你不想破坏已有的代码，想让代码一直保持可以发布（从第55页开始）。

你不能一次又一次为用户演示新功能，而浪费宝贵的开发时间，因此你需要提早实现自动化部署（第61页）。只要你的代码一直可用，并且易于向用户部署，你就能使用演示获得频繁反馈（第64页）。这样你就能经常向全世界发布新版本。你想通过使用短迭代，增量发布来帮助经常发布新功能，与用户的需求变化联系更紧密（从第69页开始介绍它）。

### 10　让客户做决定

开发者（及项目经理）能做的一个最重要的决定就是：判断哪些是自己决定不了的，应该让企业主做决定。

当你和客户讨论问题的时候，准备好几种可选择的方案。不是从技术的角度，而是从业务的角度，介绍每种方案的优缺点，以及潜在的成本和利益。和他们讨论每个选择对时间和预算的影响，以及如何权衡。无论他们做出了什么决定，他们必须接受它，所以最好让他们了解一切之后再做这些决定。如果事后他们又想要其他的东西，可以公正地就成本和时间重新谈判。

毕竟，这是他们的决定。

平衡的艺术

* 记录客户做出的决定，并注明原因。

* 不要用低级别和没有价值的问题打扰繁忙的业务人员。如果问题对他们的业务没有影响，就应该是没有价值的。

* 不要随意假设低级别的问题不会影响他们的业务。如果能影响他们的业务，就是有价值的问题。

* 如果业务负责人回答“我不知道”，这也是一个称心如意的答案。也许是他们还没有想到那么远，也许是他们只有看到运行的实物才能评估出结果。尽你所能为他们提供建议，实现代码的时候也要考虑可能出现的变化。

### 11　让设计指导而不是操纵开发

“设计”是软件开发过程不可缺少的步骤。它帮助你理解系统的细节，理解部件和子系统之间的关系，并且指导你的实现。然后，下一步才考虑是否需要开始编码。如果你在前期没有考虑清楚这些问题，就草草地开始编码，很可能会被很多意料之外的问题搞晕。

但是，即使之前已经提交了设计文档，也还会有一些意料之外的情况出现。时刻谨记，此阶段提出的设计只是基于你目前对需求的理解而已。一旦开始了编码，一切都会改变。设计及其代码实现会不停地发展和变化。

设计可以分为两层：战略和战术。前期的设计属于战略，通常只有在没有深入理解需求的时候需要这样的设计。更确切地说，它应该只描述总体战略，不应深入到具体的细节。

平衡的艺术

* “不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事。如果深入编码只是为了学习或创造原型，只要你随后能把这些代码扔掉，那也是一个不错的办法。

* 即使初始的设计到后面不再管用，你仍需设计：设计行为是无价的。正如美国总统艾森豪威尔所说：“计划是没有价值的，但计划的过程是必不可少的[4]。”在设计过程中学习是有价值的，但设计本身也许没有太大的用处。

* 白板、草图、便利贴都是非常好的设计工具。复杂的建模工具只会让你分散精力，而不是启发你的工作。

### 12　合理地使用技术

在考虑引入新技术或框架之前，先要把你需要解决的问题找出来。

* 这个技术框架真能解决这个问题吗？或者，更尖锐一点说，你是如何评估这个技术的？是通过市场宣传还是道听途说？要确保它能解决你的问题，并没有任何的毒副作用。如果需要，先做一个小的原型。
* 你将会被它拴住吗？我们要考虑它是开放技术还是专利技术，如果是开放的技术，那又开放到什么程度？
* 维护成本是多少？

### 13　保持可以发布

最好的办法是，你有一个持续集成系统，可以自动集成并报告集成结果。

可以看一看Martin Fowler的文章[7](http://www.martinfowler.com/articles/continuousIntegration.html)，或者是Mike Clark编著的图书《项目自动化之道》[Cla04]。

### 14　提早集成，频繁集成

### 15　提早实现自动化部署

### 16　使用演示获得频繁反馈

应该定期地，每隔一段时间，例如一个迭代的结束，就与客户会晤，并且演示你已经完成的功能特性。

### 17　使用短迭代，增量发布

短迭代让人感觉非常专注且具效率。你能看到一个实际并且确切的目标。严格的最终期限迫使你做出一些艰难的决策，没有遗留下长期悬而未决的问题。

### 18　固定的价格就意味着背叛承诺

评估数据会在整个项目中发生变化——它们不是固定的。

试试下面的办法。

（1）主动提议先构建系统最初的、小的和有用的部分（用建筑来打个比方，就是先做一个车库）。挑选一系列小的功能，这样完成第一次交付应该不多于6～8周。向客户解释，这时候还不是要完成所有的功能，而是要足够一次交付，并能让用户真正使用。

（2）第一个迭代结束时客户有两个选择：可以选择一系列新的功能，继续进入下一个迭代；或者可以取消合同，仅需支付第一个迭代的几周费用，他们要么把现在的成果扔掉，要么找其他的团队来完成它。

（3）如果他们选择继续前进。那么这时候，应该就能很好地预测下一个迭代工作。在下一个迭代结束的时候，用户仍然有同样的选择机会：要么现在停止，要么继续下一个迭代。

## 第5章　敏捷反馈

在上一章中，我们讨论了与用户一起紧密工作——从他们那里获得反馈，并且采取实际的行动。本章中，我们主要讨论如何从其他渠道获得反馈。按照Bill Nye的观点，实践是绝对必需的。我们会遵循这一原则，确保你明确知道项目的正确状态，而不是主观臆测。

### 19　守护天使

结合本地单元测试，运行每个编译，构建机器不断编译和运行单元测试，这样你就拥有了一个守护天使。如果出现了问题，你会立刻知道，并且这是最容易修复（也是成本最低）的时候。

### 20　先用它再实现它

使用被称为TDD（Test Driven Development，测试驱动开发）的技术，你总是在有一个失败的单元测试后才开始编码。测试总是先编写。

### 21　不同环境，就有不同问题

要在多个平台上测试，你只要为每个平台设置持续集成系统就行了

### 22　自动验收测试

关键业务逻辑必须要独立进行严格的测试，并且最后需要通过用户的审批。

应该让用户在不必学习编码的情况下，根据自己的需要进行添加、更新和修改数据。

它像是协作完成的单元测试：你仍然是在编写测试，但从其他人那里获得答案。

### 23　度量真实的进度

我们不应该去计算工作量完成的百分比，而应该测定还剩下多少工作量没有完成。

如果能一直让下一步工作是可见的，会有助于进度度量。最好的做法就是使用待办事项（backlog）。

通过待办事项，就可以随时知道下一步最重要的任务是什么。

### 24　倾听用户的声音

对客户的那些愚蠢抱怨，你既不会生气，也不会轻视。你会查看一下，找出背后真正的问题。

不管它是否是产品的bug，还是文档的bug，或者是对用户社区理解的bug，它都是团队的问题，而不是用户的问题。

## 第6章　敏捷编码

首先，第100页中的习惯是：代码要清晰地表达意图。这样的代码清晰易懂，仅凭小聪明写出的程序很难维护。注释可以帮助理解，也可能导致不好的干扰，应该总是用代码沟通（见第105页）。在工程项目中没有免费的午餐，开发人员必须判断哪些东西更加重要，每个决策会造成什么后果，也就是说要动态评估取舍（见第110页）以得到最佳的决策。

项目是以增量式方式进行开发的，写程序时也应该进行增量式编程（见第113页）。

应该编写内聚的代码。要保持代码条理清晰，应该遵循如第121页上所述的习惯：告知，不要询问。最后，通过设计能够根据契约进行替换的系统

### 25　代码要清晰地表达意图

### 26　用代码沟通

建立代码文档无外乎两种方式：利用代码本身；利用注释来沟通代码之外的问题。

注释可用来为读者指定一条正确的代码访问路线图。为代码中的每个类或模块添加一个短小的描述，说明其目的以及是否有任何特别需求。对于类中的每个方法，可能要说明下列信息。

* 目的：为什么需要这个方法？

* 需求（前置条件）：方法需要什么样的输入，对象必须处于何种状态，才能让这个方法工作？

* 承诺（后置条件）：方法成功执行后，对象现在处于什么状态，有哪些返回值？

* 异常：可能会发生什么样的问题？会抛出什么样的异常？

### 27　动态评估取舍

要想让应用成功，降低开发成本与缩短上市时间，二者的影响同样重要。

谁来最终判定性能表现已经足够好，或是应用的展现已经足够“炫”了呢？客户或是利益相关者必须进行评估，并做出相关决定（见第45页习惯10）。

没有最佳解决方案 No best solution： 动态评估权衡。考虑性能、便利性、生产力、成本和上市时间。如果性能表现足够了，就将注意力放在其他因素上。不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。

### 28　增量式编程

采取增量式编程和测试，会倾向于创建更小的方法和更具内聚性的类。

### 29　保持简单

简单、可读性高的代码

### 30　编写内聚的代码

### 31　告知，不要询问

与告知，不要询问相关的一个很有用的技术是：命令与查询相分离模式（command-query separation）。就是要将功能和方法分为“命令”和“查询”两类，并在源码中记录下来（这样做可以帮助将所有的“命令”代码放在一起，并将所有的“查询”代码放在一起）。

### 32　根据契约进行替换

Liskov替换原则：任何继承后得到的派生类对象，必须可以替换任何被使用的基类对象，而且使用者不必知道任何差异。

## 第7章　敏捷调试

在调试时面对的真正问题，是无法用固定的时间来限制。

对于一个项目来说，这种没有准确把握的时间消耗是不可接受的。不过，我们可以使用一些辅助技术，涵盖的范围包括：保留以前的问题解决方案，以及提供发生问题时的更多有用细节。

### 33　记录问题解决日志

可以选择符合需求的任何格式。下面这些条目可能会用得上。

* 问题发生日期。
* 问题简述。
* 解决方案详细描述。
* 引用文章或网址，以提供更多细节或相关信息。
* 任何代码片段、设置或对话框的截屏，只要它们是解决方案的一部分，或者可以帮助更深入地理解相关细节。

要将日志保存为可供计算机搜索的格式，就可以进行关键字搜索以快速查找细节。

### 34　警告就是错误

将警告视为错误。签入带有警告的代码，就跟签入有错误或者没有通过测试的代码一样，都是极差的做法。签入构建工具中的代码不应该产生任何警告信息。

### 35　对问题各个击破

单元测试（在第76页，第5章）带来的积极效应之一，是它会强迫形成代码的分层。

通过将问题与应用其他部分隔离开，可以将关注点直接放在与问题相关的议题上；可以通过多种改变，来接近问题发生的核心

### 36　报告所有的异常

向上传播所有的异常。不要将它们压制不管，就算是临时这样做也不行。在写代码时要估计到会发生的问题。

### 37　提供有用的错误信息

展示有用的错误信息。提供更易于查找错误细节的方式。发生问题时，要展示出尽量多的支持细节，不过别让用户陷入其中。

一方面要提供给用户清晰、易于理解的问题描述和解释，使他们有可能寻求变通之法。另一方面，还要提供具备关于错误的详细技术细节给用户，这样方便开发人员寻找代码中真正的问题所在。

## 第8章　敏捷协作

项目的成功与否，依赖于团队中的成员如何一起有效地工作，如何互动，如何管理他们的活动。全体成员的行动必须要与项目相关，反过来每个人的行为又会影响项目的环境。

1. 首先要做的是定期安排会面时间，见第148页。面对面的会议仍然是最有效的沟通方式，所以我们将以此作为本章的开篇。
2. 接下来，希望每个人都能投入到开发过程中来。也就是说架构师必须写代码（我们会在第152页看到为什么要这样做）。
3. 既然整个团队都是项目工作的一部分，我们希望实行代码集体所有制（见第155页），以保证任何团队成员的缺席不会对项目造成影响。这就是协作的效果。
4. 团队中每个人都要强化和提高他们的技能，并且推进各自的职业发展。即使一个人刚刚加入团队，他也可以成为指导者
5. 最后，由于大家都是在团队中一起工作，每个人就要修改自己的个人编码习惯，来适应团队的其他成员

### 38　定期安排会面时间

立会（站着开的会议，Scrum最早引入并被极限编程所强调的一个实践）是将团队召集在一起，并让每个人了解当下进展状况的好办法。立会的时间最长不能超出30分钟，10～15分钟比较理想。

要保证会议议题不会发散，每个人都应该只回答下述三个问题。

* 昨天有什么收获？
* 今天计划要做哪些工作？
* 面临着哪些障碍？

如果要详细讨论某些问题，可以在立会结束之后，再召集相关人员（在会议中说“我需要跟Fred和Wilma讨论一下数据库”是没有问题的，但是不要深入讨论细节）。

### 39　架构师必须写代码

要鼓励程序员参与设计。主力程序员应该试着担任架构师的角色，而且可以从事多种不同的角色。他会负责解决设计上的问题，同时也不会放弃编码的工作。

### 40　实行代码集体所有制

在团队中实行任务轮换制，让每个成员都可以接触到不同部分的代码，可以提升团队整体的知识和专业技能。

### 41　成为指导者

1. 与团队其他人一起共事是很好的学习机会。
2. 通过详细解释自己知道的东西，可以使自己的理解更深入。
3. 与别人共事，激励他们变得更出色，同时可以提升团队的整体实力。
4. 不必局限于自己的团队。可以开设个人博客，贴一些代码和技术在上面。不一定是多么伟大的项目，即使是一小段代码和解释，对别人也可能是有帮助的。

### 42　允许大家自己想办法

给别人解决问题的机会。指给他们正确的方向，而不是直接提供解决方案。每个人都能从中学到不少东西。

### 43　准备好后再共享代码

要保证在提交代码之前，所有的单元测试都是可以通过的。使用持续集成是保证源代码控制系统中代码没有问题的一种良好方式。

### 44　做代码复查

在代码复查中要看什么呢？你可能会制订出要检查的一些特定问题列表（所有的异常处理程序不允许空，所有的数据库调用都要在包的事务中进行，等等），不过这里是一个可供启动的最基本的检查列表。

* 代码能否被读懂和理解？
* 是否有任何明显的错误？
* 代码是否会对应用的其他部分产生不良影响？
* 是否存在重复的代码（在复查的这部分代码中，或是在系统的其他部分代码）？
* 是否存在可以改进或重构的部分？

### 45　及时通报进展与问题

及时通报进展与问题。发布进展状况、新的想法和目前正在关注的主题。不要等着别人来问项目状态如何。

## 第9章　尾声：走向敏捷

### 9.1　只要一个新的习惯

从立会开始（习惯38 定期安排会面时间）

### 9.2　拯救濒临失败的项目

使用了下面这些促进沟通和协作的敏捷习惯作为开始：第18页习惯3 对事不对人，第148页习惯38 定期安排会面时间，第162页习惯43 准备好后再共享代码，以及第168页习惯45 及时通报进展与问题。

以此为起点，下一步要引入一些与发布相关的习惯，比如第55页习惯13 保持可以发布，第58页习惯14 提早集成，频繁集成。

最终，他们采纳了一些与编码相关的习惯，比如第132页习惯34 警告就是错误，第136页习惯35 对问题各个击破。

### 9.3　引入敏捷：管理者指南

从立会开始（见第148页习惯38 定期安排会面时间）。这可以让团队有机会进行彼此讨论，并对一些重大问题达成共识。把之前相对孤立的架构师带到团队中，并让他们参与到日常开发工作（见第152页习惯39 架构师必须写代码）。开展非正式的代码复查（见第165页习惯44），并做出计划，让客户与用户也参与到项目中来（见第45页习惯10 让客户做决定）。

接下来要准备好开发的基本环境。也就是说要开始采纳（或改进）基本的入门级别习惯。

* 版本控制
* 单元测试
* 自动构建

在设定环境时，可以回顾一下在第76页第5章，接下来再看看在第98页第6章和第138页第7章，了解如何以敏捷的方式来解决日常问题。

最后，开始引入在第26页第3章提到的自备午餐会和其他习惯，并开始使用在第146页第8章敏捷协作的习惯，让团队可以紧密配合，共同工作。

### 9.4　引入敏捷：程序员指南

如果要将团队带入新的领域，必须首先以身作则。所以不妨从可以马上着手的习惯做起。在第10页第2章中的习惯是个不错的起点，比如这几个偏重编码的习惯：第78页习惯19 守护天使和第82页习惯20 先用它再实现它；还有第98页第6章和第128页第7章中的习惯。还可以在自己机器上运行一个持续构建服务器，发生问题时可以马上知道。队友可能会觉得你有“千里眼”呢。

过些时间之后，可以试着开始一些非正式的自备午餐会（见第31页习惯6 对团队投资），与大家一起讨论关于敏捷项目的节奏（见第40页习惯9 把握开发节奏）和其他感兴趣的话题。
