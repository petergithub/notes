# 软件设计之美

郑晔

软件最核心的三个部分：模型、接口和实现。

软件设计中最重要的部分交付给你，包括：

* 程序设计语言；
* 编程范式；
* 设计原则；
* 设计模式；
* 设计方法。

编程范式，是代码编写的风格，决定着你在设计时可以用到哪些元素：是模块、是对象，还是函数。

设计原则，是你在进入到具体设计的层面时，可以用来评判自己工作结果的一个衡量标准。我会给你介绍面向对象的主流设计原则：SOLID原则。

领域驱动设计（也就是 DDD，Domain Driven Design）是目前最为完整、有效的应对复杂业务场景的设计方法，包括了从如何识别概念到如何建立模型。

## 01 软件设计到底是什么？

模型，是一个软件的骨架，是一个软件之所以是这个软件的核心。模型的粒度可大可小。我们所说的“高内聚、低耦合”指的就是对模型的要求，一个好的模型可以有效地隐藏细节，让开发者易于理解。模型是分层的，可以不断地叠加，基于一个基础的模型去构建上一层的模型，计算机世界就是这样一点点构建出来的。

规范，就是限定了什么样的需求应该以怎样的方式去完成。它对于维系软件长期演化至关重要。关于规范，常见的两种问题是：一个项目缺乏显式的、统一的规范；规范不符合软件设计原则。

## 02 分离关注点：软件设计至关重要的第一步

大多数系统的设计做得不够好，问题常常出现在分解这步就没做好。常见的分解问题就是分解的粒度太大，把各种维度混淆在一起。在设计中，将一个模块的不同维度分开，有一个专门的说法，叫分离关注点。

不同的数据变动方向还有很多，比如：

动静分离，就是把变和不变的内容分开；
读写分离，就是把读和写分开；
前面提到的高频和低频，也可以分解开；
……
不同的数据变动方向，就是一个潜在的、可以分离的关注点。

在实际的项目中，可以分离的关注点远不止这些。做设计时，你需要一直有一根弦去发现不同的关注点。分离关注点，不只适用于宏观的层面。

## 03 可测试性：一个影响软件设计的重要因素

做软件设计，请考虑可测试性。

软件开发要解决的问题是从需求而来。需求包括两大类，

1. 第一类是功能性需求，也就是要完成怎样的业务功能；
2. 第二类是非功能性需求，是业务功能之外的一些需求。
   1. 一类称为执行质量（Execution qualities），包括吞吐、延迟、安全，它们都是可以在运行时通过运维手段被观察到的
   2. 另一类称为演化质量（Evolution qualities），它们内含于一个软件的结构之中，包括可测试性、可维护性、可扩展性等。
      1. 可测试性
      2. 可维护性
      3. 可扩展性

在设计一个函数/模块/系统时，必须将可测试性纳入考量，以便于能够完成不同层次的测试，减少对集成环境的依赖。

## 04 三步走：如何了解一个软件的设计？

了解一个软件的设计可以从三个部分着手：模型、接口和实现

* 模型，也可以称为抽象，是一个软件的核心部分，是这个系统与其它系统有所区别的关键，是我们理解整个软件设计最核心的部分。
* 接口，是通过怎样的方式将模型提供的能力暴露出去，是我们与这个软件交互的入口。
* 实现，就是软件提供的模型和接口在内部是如何实现的，是软件能力得以发挥的根基。

## 05 Spring DI容器：如何分析一个软件的模型？

如果拿到一个项目，我们怎么去理解它的模型呢？我们肯定要先知道项目提供了哪些模型，模型又提供了怎样的能力。

任何模型都是为了解决问题而生的，所以，理解一个模型，需要了解在没有这个模型之前，问题是如何被解决的，这样，你才能知道新的模型究竟提供了怎样的提升。

DI容器要解决的问题是什么呢？它解决的是组件创建和组装的问题。

理解模型，要了解模型设计的来龙去脉。

## 06 Ruby on Rails：如何分析一个软件的接口？

如何才能从纷繁复杂的接口中，披荆斩棘而出呢？我给你个方法：找主线，看风格。

找主线的意思是，你需要找到一条功能主线，建立起对这个项目结构性的认知，而不是一上来就把精力放在每一个接口的细节上。

但是，我们要学习的不只是这些接口的用法，要想从项目的接口设计上学到更多，这就需要你关注它所引导的风格，换句话说，就是它希望你怎样使用它，或是怎样在上面继续开发。

曾经火爆的Web开发框架：Ruby on Rails 提供三种接口，包括：

* Web应用对外暴露的接口：REST API；
* 程序员写程序时用到的接口：API；
* 程序员在开发过程中用到的接口：命令行。

## 07 Kafka：如何分析一个软件的实现？

两个关键点：软件的结构和关键的技术。

消息队列的模型与接口：

消息队列是Kafka这个软件的核心模型，而流平台显然是这个核心模型存在之后的扩展。所以，我们要先把焦点放在Kafka的核心模型——消息队列上。

消息队列的基本接口：生产者发消息，消费者收消息

消息队列还有一个最常见的特性是，它会提供一定的消息存储能力。

Kafka之所以能从一众消息队列实现中脱颖而出，一个重要的原因就是，它针对消息写入做了优化，它的生产者写入速度特别快。从整体的表现上看，就是吞吐能力特别强。

Kafka这个实现到底是哪里不容易想到呢？答案是软硬结合。

## 08 语言的模型：如何打破单一语言局限，让设计更好地落地？

《程序员修炼之道》鼓励程序员们每年至少学习一门新语言，主要是为了让我们去学习新的编程模型，而不提供新编程模型的语言不值得刻意去学习。

一些程序设计语言为例：

* C语言提供了对汇编指令直接的封装。
* C++先是提供了面向对象，后来又提供了泛型编程。
* Java把内存管理从开发者面前去掉了，后来引入的Annotation可以进行声明式编程。
* Ruby提供了动态类型，以及由Ruby on Rails引导出的DSL风格。
* Scala和Clojure提供了函数式编程。
* Rust提供了新的内存管理方式，而Libra提供的Move语言则把它进一步抽象成了资源的概念。

## 09 语言的接口：语法和程序库，软件设计的发力点

程序库最初只是为了消除重复。后来，逐渐有了标准库，然后有了大量的第三方库，进而发展出包管理器。

语言设计就是程序库设计，程序库设计就是语言设计。二者相互促进，不断发展。

## 10 语言的实现：运行时，软件设计的地基

做设计真正的地基，并不是程序设计语言，而是运行时，有了对于运行时的理解，我们甚至可以做出语言本身不支持的设计。

## 11 DSL：你也可以设计一门自己的语言
## 加餐 再八卦几门语言！
## 12 编程范式：明明写的是Java，为什么被人说成了C代码？
## 13 结构化编程：为什么做设计时仅有结构化编程是不够的？
## 14 面向对象之封装：怎样的封装才算是高内聚？
## 15 面向对象之继承：继承是代码复用的合理方式吗？
## 16 面向对象之多态：为什么“稀疏平常”的多态，是软件设计的大杀器？
## 17 函数式编程：不用函数式编程语言，怎么写函数式的程序？
## 18 函数式编程之组合性：函数式编程为什么如此吸引人？
## 19 函数式编程之不变性：怎样保证我的代码不会被别人破坏？
## 加餐 函数式编程拾遗

## 20 单一职责原则：你的模块到底为谁负责？

SOLID原则分别是：

* 单一职责原则（Single responsibility principle，SRP）
* 开放封闭原则（Open–closed principle，OCP）
* Liskov替换原则（Liskov substitution principle，LSP）
* 接口隔离原则（Interface segregation principle，ISP）
* 依赖倒置原则（Dependency inversion principle，DIP）

单一职责原则讲的并不是一个类只做一件事，它的关注点在于变化。其最初的定义是一个模块应该有且仅有一个变化的原因，后来其定义升级为一个模块应该对一类且仅对一类行为者负责。这个定义从考虑变化升级到考虑变化的来源。

## 21 开放封闭原则：不改代码怎么写新功能？

软件实体（类、模块、函数）应该对扩展开放，对修改封闭。

## 22 Liskov替换原则：用了继承，子类就设计对了吗？

子类型（subtype）必须能够替换其父类型（base type）。

## 23 接口隔离原则：接口里的方法，你都用得到吗？

不应强迫使用者依赖于它们不用的方法

ISP还可以从更广泛的角度去理解，也就是说，不要依赖于任何不需要的东西，这个原则可以指导我们在高层次上进行设计。

识别对象的不同角色，设计小接口

## 24 依赖倒置原则：高层代码和底层代码，到底谁该依赖谁？

高层模块不应依赖于低层模块，二者应依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。

## 25 设计模式：每一种都是一个特定问题的解决方案

学习设计模式不要贪多求全，那注定会是一件费力不讨好的事。

学习设计模式不仅仅要学习代码怎么写，更重要的是要了解模式的应用场景。

## 26 简单设计：难道一开始就要把设计做复杂吗？

三个原则

* KISS，Keep it simple, stupid，让系统保持简单；
* YAGNI，You aren’t gonna need it，你用不着它，可以理解成：如非必要，勿增功能。它告诫我们，不要做不该做的需求；
* DRY，Don’t repeat yourself，也就是，不要重复自己，消除各种重复。

简单设计（Simple Design）原则，包含了4条规则：

* 通过所有测试；
* 消除重复；
* 表达出程序员的意图；
* 让类和方法的数量最小化。

1. 第1条是保证系统能够按照预期工作，后面3条规则其实说的是重构的方向。
2. 第2条，消除重复，正如前面讲DRY原则所说的，你得能够发现重复，这需要你对分离关注点有着深刻的认识。
3. 第3条，表达出程序员的意图，我们需要编写有表达性的代码，这也需要你对“什么是有表达性的代码”有认识。我们在讲DSL曾经说过，代码要说明做什么，而不是怎么做。
4. 第4条，让类和方法的数量最小化，则告诉我们不要过度设计，除非你已经看到这个地方必须要做一个设计，比如，留下适当的扩展点，否则，就不要做。

## 27 领域驱动设计：如何从零开始设计一个软件？

## 28 战略设计：如何划分系统的模块？

战略设计，就是将不同的模型进行分组。

战略设计中的概念主要是为了做业务的划分和落地成解决方案。

首先业务的划分，我们要把识别出来的模型做一个分类，把它们放置到不同的子域中。划分子域的出发点就是不同的关注点，也就是不同的变化来源。

划分出来的子域有着不同的重要程度，我们将它们再分为核心域（Core Domain）、支撑域（Supporting Subdomain）和通用域（Generic Subdomain）。做出这种区分，主要是为了针对它们各自的特点，决定不同的投入。核心域要全力投入，支撑域次之，通用域甚至可以花钱买服务。

核心域是整个系统最重要的部分，是整个业务得以成功的关键。

什么是支撑域呢？有一些子域不是你的核心竞争力，但却是系统不得不做的东西，市场上也找不到一个现成的方案，这种子域就是支撑域。

还有一种子域叫通用域，就是行业里通常都是这么做，即便不自己做，也并不影响你的业务运行。比如，很多 App 要给用户发通知。

## 29 战术设计：如何像写故事一样找出模型？
## 30 程序库的设计：Moco是如何解决集成问题的？
## 31 应用的设计：如何设计一个数据采集平台？
## 32 应用的改进：如何改进我们的软件设计？
## 结束 语｜那些没讲的事儿
